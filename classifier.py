__author__ = "Ayushi Churiwala"  

from pandas import read_excel, Series

import numpy as np 
import pandas as pd
import matplotlib.pyplot as plt

from sklearn.ensemble import ExtraTreesClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.datasets import make_classification
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import classification_report
from sklearn.utils import resample
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
from pandas import read_excel

# use following instruction to load the training dataset from disk
# training_set = read_excel("train.xlsx")

class BinaryClassification(nn.Module):
    def __init__(self):
        super(BinaryClassification, self).__init__()
        # Number of input features is 12.
        self.layer_1 = nn.Linear(20, 300) 
        self.layer_2 = nn.Linear(300, 100)
        self.layer_3 = nn.Linear(100, 100)
        self.layer_4 = nn.Linear(100, 100)
        self.layer_out = nn.Linear(100, 1) 
        
        self.relu = nn.LeakyReLU()
        self.dropout = nn.Dropout(p=0.1)
        self.batchnorm1 = nn.BatchNorm1d(300)
        self.batchnorm2 = nn.BatchNorm1d(100)
        
    def forward(self, inputs):
        x = self.relu(self.layer_1(inputs))
        x = self.batchnorm1(x)
        x = self.relu(self.layer_2(x))        
        x = self.batchnorm2(x)
        x = self.dropout(x)
        x = self.relu(self.layer_3(x))
        x = self.batchnorm2(x)
        x = self.dropout(x)
        x = self.relu(self.layer_4(x))
        x = self.batchnorm2(x)
        x = self.dropout(x)
        x = self.layer_out(x)
        return x
    
class MalwareClassifier:

    def __init__(self):
    
        self.model = BinaryClassification()
        self.model.load_state_dict(torch.load("\\Model\\model.pt"))
        self.model.eval()
        self.encoderRelated = LabelEncoder()
        self.encoderRelated.classes_ = np.load('\\classes.npy',allow_pickle=True)
        self.encoderCategory = LabelEncoder()
        self.encoderCategory.classes_ = np.load('\\Model\\classesCategory.npy',allow_pickle=True)
        pass


    def is_malware(self, metadata: Series) -> bool:
        #metadata = metadata.to_dict()
        
        le_name_mapping = dict(zip(self.encoderRelated.classes_, self.encoderRelated.transform(self.encoderRelated.classes_)))
        cat_name_mapping = dict(zip(self.encoderCategory.classes_, self.encoderCategory.transform(self.encoderCategory.classes_)))
        
        metadata["related"] = le_name_mapping.get(metadata["Related apps"], 0)
        #metadata["related"] = self.encoderRelated.transform([metadata["Related apps"]])
        metadata["CategoryLabel"] = cat_name_mapping.get(metadata["Category"], 0)
        #metadata['CategoryLabel'] = self.encoderCategory.transform([metadata['Category']])
        
        metadata = metadata.drop('App')
        metadata = metadata.drop('Package')
        metadata = metadata.drop('Category')
        metadata = metadata.drop('Description')
        metadata = metadata.drop('Related apps')
        
        
        imp = ['Dangerous permissions count', 'Safe permissions count',
       'Hardware controls : control vibrator (S)',
       'Hardware controls : record audio (D)',
       'Hardware controls : take pictures and videos (D)',
       'Network communication : full Internet access (D)',
       'Network communication : view Wi-Fi state (S)',
       'Network communication : view network state (S)',
       'Phone calls : read phone state and identity (D)',
       'Services that cost you money : directly call phone numbers (D)',
       'Storage : modify/delete USB storage contents modify/delete SD card contents (D)',
       'System tools : automatically start at boot (S)',
       'System tools : modify global system settings (D)',
       'System tools : prevent device from sleeping (D)',
       'System tools : set wallpaper (S)',
       'Your location : coarse (network-based) location (D)',
       'Your location : fine (GPS) location (D)',
       'Your personal information : read contact data (D)', 'related',
       'CategoryLabel']
        
        for x in metadata.index.to_list():
            if x not in imp:
                metadata = metadata.drop(x)
        a = []
        for x in metadata.values:
            a.append(x)
        
        x_test = torch.FloatTensor(a)
        
        with torch.no_grad():
            y_test_pred = self.model(x_test.unsqueeze(0))
            y_test_pred = torch.sigmoid(y_test_pred)
            y_pred_tag = torch.round(y_test_pred).item()

        
        return y_pred_tag
